return(totalProbZero)
})
registerDistributions(list(
dZIP = list(
BUGSdist = "dZIP(lambda, zeroProb)",
discrete = TRUE,
range = c(0, Inf),
types = c('value = integer()', 'lambda = double()', 'zeroProb = double()')
)))
modelcode <- nimbleCode({
## priors
beta0 ~ dnorm(0.0, sd = prec.beta0)  # vague prior on intercept
gamma0 ~ dnorm(0.0, sd=prec.gamma0)
beta1~ dnorm(0.0, sd = prec.gamma1)
gamma1~ dnorm(0.0, sd = prec.beta1)
theta.c ~ dnorm(0.0, sd=prec.theta.c)
theta.ci ~ dnorm(0.0, sd=prec.theta.ci)
# priors for precision of normal distributions
prec.beta0 ~ dgamma(0.1, 0.1)
prec.gamma0 ~ dgamma(0.1, 0.1)
prec.gamma1 ~ dgamma(0.1,0.1)
prec.beta1 ~ dgamma(0.1,0.1)
prec.theta.c ~dgamma(0.1, 0.1)
prec.theta.ci ~dgamma(0.1,0.1)
prec.c ~ dgamma(0.1, 0.1)
prec.ci ~ dgamma(0.1, 0.1)
prec.h ~ dgamma(0.1, 0.1)
prec.hi ~ dgamma(0.1, 0.1)
prec.t ~ dgamma(0.1, 0.1)
prec.t.hat~dgamma(0.1,0.1)
# CAR model for spatial random effects
phi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.c, zero_mean=0)
psi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.ci, zero_mean=0)
# likelihood
for (i in 1 : n.twnshps) {
for(j in 2: n.years){
omega[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t)
omegaHat[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t.hat)
log(mu[i,j]) <- s[i,j]*mu.hat  + theta.c*omega[i,j]+  phi[i] + beta0
logit(p[i,j]) <- s[i,j]*mu.hat + theta.ci * omegaHat[i,j] + psi[i] + gamma0
# lambda[i,j]  ~ dnorm(0, sd=tau.t)
# lambdaHat[i,j] ~ dnorm(0, sd=tau.t.hat)
y[i,j] ~ dZIP(mu[i,j], p[i,j])
}
epsilon[i] <- theta[i] + phi[i]
epsilon.hat[i] <- psi[i] + eta[i]
theta[i] ~ dnorm(0.0, prec.c)
eta[i] ~ dnorm(0.0, prec.ci)
}
## calculate alpha
sd.h <- sd(phi[1:n.twnshps]) # marginal SD of heterogeneity effects
sd.c <- sd(theta[1:n.twnshps])   # marginal SD of clustering (spatial) effects
sd.hi <- sd(psi[1:n.twnshps])
sd.ci <- sd(eta[1:n.twnshps])
alpha <- sd.h / (sd.c + sd.h)
alpha.i <- sd.hi/(sd.ci + sd.hi)
sigma2 <- 1/prec.h
tau2 <- 1/prec.c
sigma2i <- 1/prec.hi
tau2i <- 1/prec.ci
tau.t <-1/prec.t
tau.t.hat <- 1/prec.t.hat
})
## Specify data and initial values
constants <- list(n.twnshps = nrow(cwd.mat.analyzed),
mu.hat=cwd.r,
n.years=length(yearSamp),
L = length(W$adj),
adj=W$adj,
weights=W$weights,
num=W$num)
data <- list(y = cwd.mat.pos,
s = cwd.mat.analyzed)
inits <- list(beta0 = 0,
beta1=0,
theta.c = 0,
theta.ci = 0,
gamma1=0,
gamma0 = 0)
## Build/Compile model, including steps:
## (1) build model (2) compile model in C++
## (3) specify MCMC parameters to collect and create MCMC algorithm
cwdspatmodel <- nimbleModel(modelcode, constants = constants, data = data, inits = inits)
c.cwdspatmodel <- compileNimble(cwdspatmodel, showCompilerOutput = TRUE)
# year samp will be the number of years we're getting CWD samples for
yearSamp<-c(seq(2003,2022, 1))
# let's create our expected value
cwd.r<-sum(cwd.mat.pos)/sum(cwd.mat.analyzed)
# create neighborhood matrix
W.nb <- poly2nb(wiStudyShp)
W <- nb2WB(W.nb)
dZIP <- nimbleFunction(
run = function(x = integer(), lambda = double(),
zeroProb = double(), log = logical(0, default = 0)) {
returnType(double())
## First handle non-zero data
if (x != 0) {
## return the log probability if log = TRUE
if (log) return(dpois(x, lambda, log = TRUE) + log(1 - zeroProb))
## or the probability if log = FALSE
else return((1 - zeroProb) * dpois(x, lambda, log = FALSE))
}
## From here down we know x is 0
totalProbZero <- zeroProb + (1 - zeroProb) * dpois(0, lambda, log = FALSE)
if (log) return(log(totalProbZero))
return(totalProbZero)
})
registerDistributions(list(
dZIP = list(
BUGSdist = "dZIP(lambda, zeroProb)",
discrete = TRUE,
range = c(0, Inf),
types = c('value = integer()', 'lambda = double()', 'zeroProb = double()')
)))
modelcode <- nimbleCode({
## priors
beta0 ~ dnorm(0.0, sd = prec.beta0)  # vague prior on intercept
gamma0 ~ dnorm(0.0, sd=prec.gamma0)
beta1~ dnorm(0.0, sd = prec.gamma1)
gamma1~ dnorm(0.0, sd = prec.beta1)
theta.c ~ dnorm(0.0, sd=prec.theta.c)
theta.ci ~ dnorm(0.0, sd=prec.theta.ci)
# priors for precision of normal distributions
prec.beta0 ~ dgamma(0.1, 0.1)
prec.gamma0 ~ dgamma(0.1, 0.1)
prec.gamma1 ~ dgamma(0.1,0.1)
prec.beta1 ~ dgamma(0.1,0.1)
prec.theta.c ~dgamma(0.1, 0.1)
prec.theta.ci ~dgamma(0.1,0.1)
prec.c ~ dgamma(0.1, 0.1)
prec.ci ~ dgamma(0.1, 0.1)
prec.h ~ dgamma(0.1, 0.1)
prec.hi ~ dgamma(0.1, 0.1)
prec.t ~ dgamma(0.1, 0.1)
prec.t.hat~dgamma(0.1,0.1)
# CAR model for spatial random effects
phi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.c, zero_mean=0)
psi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.ci, zero_mean=0)
# likelihood
for (i in 1 : n.twnshps) {
for(j in 2: n.years){
omega[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t)
omegaHat[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t.hat)
log(mu[i,j]) <- theta.c*omega[i,j]+ beta1*precip[i,j] + phi[i] + beta0
logit(p[i,j]) <- theta.ci * omegaHat[i,j] + gamma1*precip[i,j] + psi[i] + gamma0
# lambda[i,j]  ~ dnorm(0, sd=tau.t)
# lambdaHat[i,j] ~ dnorm(0, sd=tau.t.hat)
y[i,j] ~ dZIP(mu[i,j], p[i,j])
}
epsilon[i] <- theta[i] + phi[i]
epsilon.hat[i] <- psi[i] + eta[i]
theta[i] ~ dnorm(0.0, prec.c)
eta[i] ~ dnorm(0.0, prec.ci)
}
## calculate alpha
sd.h <- sd(phi[1:n.twnshps]) # marginal SD of heterogeneity effects
sd.c <- sd(theta[1:n.twnshps])   # marginal SD of clustering (spatial) effects
sd.hi <- sd(psi[1:n.twnshps])
sd.ci <- sd(eta[1:n.twnshps])
alpha <- sd.h / (sd.c + sd.h)
alpha.i <- sd.hi/(sd.ci + sd.hi)
sigma2 <- 1/prec.h
tau2 <- 1/prec.c
sigma2i <- 1/prec.hi
tau2i <- 1/prec.ci
tau.t <-1/prec.t
tau.t.hat <- 1/prec.t.hat
})
## Specify data and initial values
constants <- list(n.twnshps = nrow(cwd.mat.analyzed),
mu.hat=cwd.r,
n.years=length(yearSamp),
L = length(W$adj),
adj=W$adj,
weights=W$weights,
num=W$num)
data <- list(y = cwd.mat.pos,
s = cwd.mat.analyzed)
inits <- list(beta0 = 0,
beta1=0,
theta.c = 0,
theta.ci = 0,
gamma1=0,
gamma0 = 0)
## Build/Compile model, including steps:
## (1) build model (2) compile model in C++
## (3) specify MCMC parameters to collect and create MCMC algorithm
cwdspatmodel <- nimbleModel(modelcode, constants = constants, data = data, inits = inits)
c.cwdspatmodel <- compileNimble(cwdspatmodel, showCompilerOutput = TRUE)
# year samp will be the number of years we're getting CWD samples for
yearSamp<-c(seq(2003,2022, 1))
# let's create our expected value
cwd.r<-sum(cwd.mat.pos)/sum(cwd.mat.analyzed)
# create neighborhood matrix
W.nb <- poly2nb(wiStudyShp)
W <- nb2WB(W.nb)
dZIP <- nimbleFunction(
run = function(x = integer(), lambda = double(),
zeroProb = double(), log = logical(0, default = 0)) {
returnType(double())
## First handle non-zero data
if (x != 0) {
## return the log probability if log = TRUE
if (log) return(dpois(x, lambda, log = TRUE) + log(1 - zeroProb))
## or the probability if log = FALSE
else return((1 - zeroProb) * dpois(x, lambda, log = FALSE))
}
## From here down we know x is 0
totalProbZero <- zeroProb + (1 - zeroProb) * dpois(0, lambda, log = FALSE)
if (log) return(log(totalProbZero))
return(totalProbZero)
})
registerDistributions(list(
dZIP = list(
BUGSdist = "dZIP(lambda, zeroProb)",
discrete = TRUE,
range = c(0, Inf),
types = c('value = integer()', 'lambda = double()', 'zeroProb = double()')
)))
modelcode <- nimbleCode({
## priors
beta0 ~ dnorm(0.0, sd = prec.beta0)  # vague prior on intercept
gamma0 ~ dnorm(0.0, sd=prec.gamma0)
beta1~ dnorm(0.0, sd = prec.gamma1)
gamma1~ dnorm(0.0, sd = prec.beta1)
theta.c ~ dnorm(0.0, sd=prec.theta.c)
theta.ci ~ dnorm(0.0, sd=prec.theta.ci)
# priors for precision of normal distributions
prec.beta0 ~ dgamma(0.1, 0.1)
prec.gamma0 ~ dgamma(0.1, 0.1)
prec.gamma1 ~ dgamma(0.1,0.1)
prec.beta1 ~ dgamma(0.1,0.1)
prec.theta.c ~dgamma(0.1, 0.1)
prec.theta.ci ~dgamma(0.1,0.1)
prec.c ~ dgamma(0.1, 0.1)
prec.ci ~ dgamma(0.1, 0.1)
prec.h ~ dgamma(0.1, 0.1)
prec.hi ~ dgamma(0.1, 0.1)
prec.t ~ dgamma(0.1, 0.1)
prec.t.hat~dgamma(0.1,0.1)
# CAR model for spatial random effects
phi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.c, zero_mean=0)
psi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.ci, zero_mean=0)
# likelihood
for (i in 1 : n.twnshps) {
for(j in 2: n.years){
# omega[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t)
# omegaHat[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t.hat)
log(mu[i,j]) <- beta1*precip[i,j] + phi[i] + beta0
logit(p[i,j]) <- gamma1*precip[i,j] + psi[i] + gamma0
# lambda[i,j]  ~ dnorm(0, sd=tau.t)
# lambdaHat[i,j] ~ dnorm(0, sd=tau.t.hat)
y[i,j] ~ dZIP(mu[i,j], p[i,j])
}
epsilon[i] <- theta[i] + phi[i]
epsilon.hat[i] <- psi[i] + eta[i]
theta[i] ~ dnorm(0.0, prec.c)
eta[i] ~ dnorm(0.0, prec.ci)
}
## calculate alpha
sd.h <- sd(phi[1:n.twnshps]) # marginal SD of heterogeneity effects
sd.c <- sd(theta[1:n.twnshps])   # marginal SD of clustering (spatial) effects
sd.hi <- sd(psi[1:n.twnshps])
sd.ci <- sd(eta[1:n.twnshps])
alpha <- sd.h / (sd.c + sd.h)
alpha.i <- sd.hi/(sd.ci + sd.hi)
sigma2 <- 1/prec.h
tau2 <- 1/prec.c
sigma2i <- 1/prec.hi
tau2i <- 1/prec.ci
tau.t <-1/prec.t
tau.t.hat <- 1/prec.t.hat
})
## Specify data and initial values
constants <- list(n.twnshps = nrow(cwd.mat.analyzed),
mu.hat=cwd.r,
n.years=length(yearSamp),
L = length(W$adj),
adj=W$adj,
weights=W$weights,
num=W$num)
data <- list(y = cwd.mat.pos,
s = cwd.mat.analyzed)
inits <- list(beta0 = 0,
beta1=0,
theta.c = 0,
theta.ci = 0,
gamma1=0,
gamma0 = 0)
## Build/Compile model, including steps:
## (1) build model (2) compile model in C++
## (3) specify MCMC parameters to collect and create MCMC algorithm
cwdspatmodel <- nimbleModel(modelcode, constants = constants, data = data, inits = inits)
c.cwdspatmodel <- compileNimble(cwdspatmodel, showCompilerOutput = TRUE)
weights
W$weights
# year samp will be the number of years we're getting CWD samples for
yearSamp<-c(seq(2003,2022, 1))
# let's create our expected value
cwd.r<-sum(cwd.mat.pos)/sum(cwd.mat.analyzed)
# create neighborhood matrix
W.nb <- poly2nb(wiStudyShp)
W <- nb2WB(W.nb)
dZIP <- nimbleFunction(
run = function(x = integer(), lambda = double(),
zeroProb = double(), log = logical(0, default = 0)) {
returnType(double())
## First handle non-zero data
if (x != 0) {
## return the log probability if log = TRUE
if (log) return(dpois(x, lambda, log = TRUE) + log(1 - zeroProb))
## or the probability if log = FALSE
else return((1 - zeroProb) * dpois(x, lambda, log = FALSE))
}
## From here down we know x is 0
totalProbZero <- zeroProb + (1 - zeroProb) * dpois(0, lambda, log = FALSE)
if (log) return(log(totalProbZero))
return(totalProbZero)
})
registerDistributions(list(
dZIP = list(
BUGSdist = "dZIP(lambda, zeroProb)",
discrete = TRUE,
range = c(0, Inf),
types = c('value = integer()', 'lambda = double()', 'zeroProb = double()')
)))
modelcode <- nimbleCode({
## priors
beta0 ~ dnorm(0.0, sd = prec.beta0)  # vague prior on intercept
gamma0 ~ dnorm(0.0, sd=prec.gamma0)
beta1~ dnorm(0.0, sd = prec.gamma1)
gamma1~ dnorm(0.0, sd = prec.beta1)
theta.c ~ dnorm(0.0, sd=prec.theta.c)
theta.ci ~ dnorm(0.0, sd=prec.theta.ci)
# priors for precision of normal distributions
prec.beta0 ~ dgamma(0.1, 0.1)
prec.gamma0 ~ dgamma(0.1, 0.1)
prec.gamma1 ~ dgamma(0.1,0.1)
prec.beta1 ~ dgamma(0.1,0.1)
prec.theta.c ~dgamma(0.1, 0.1)
prec.theta.ci ~dgamma(0.1,0.1)
prec.c ~ dgamma(0.1, 0.1)
prec.ci ~ dgamma(0.1, 0.1)
prec.h ~ dgamma(0.1, 0.1)
prec.hi ~ dgamma(0.1, 0.1)
prec.t ~ dgamma(0.1, 0.1)
prec.t.hat~dgamma(0.1,0.1)
# CAR model for spatial random effects
phi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.c, zero_mean=0)
psi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.ci, zero_mean=0)
# likelihood
for (i in 1 : n.twnshps) {
for(j in 2: n.years){
# omega[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t)
# omegaHat[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t.hat)
log(mu[i,j]) <- theta.c*omega[i,j]+ beta1*precip[i,j] +  beta0
logit(p[i,j]) <- theta.ci * omegaHat[i,j] + gamma1*precip[i,j] + gamma0
# lambda[i,j]  ~ dnorm(0, sd=tau.t)
# lambdaHat[i,j] ~ dnorm(0, sd=tau.t.hat)
y[i,j] ~ dZIP(mu[i,j], p[i,j])
}
epsilon[i] <- theta[i] + phi[i]
epsilon.hat[i] <- psi[i] + eta[i]
theta[i] ~ dnorm(0.0, prec.c)
eta[i] ~ dnorm(0.0, prec.ci)
}
## calculate alpha
sd.h <- sd(phi[1:n.twnshps]) # marginal SD of heterogeneity effects
sd.c <- sd(theta[1:n.twnshps])   # marginal SD of clustering (spatial) effects
sd.hi <- sd(psi[1:n.twnshps])
sd.ci <- sd(eta[1:n.twnshps])
alpha <- sd.h / (sd.c + sd.h)
alpha.i <- sd.hi/(sd.ci + sd.hi)
sigma2 <- 1/prec.h
tau2 <- 1/prec.c
sigma2i <- 1/prec.hi
tau2i <- 1/prec.ci
tau.t <-1/prec.t
tau.t.hat <- 1/prec.t.hat
})
## Specify data and initial values
constants <- list(n.twnshps = nrow(cwd.mat.analyzed),
mu.hat=cwd.r,
n.years=length(yearSamp),
L = length(W$adj),
adj=W$adj,
weights=W$weights,
num=W$num)
data <- list(y = cwd.mat.pos,
s = cwd.mat.analyzed)
inits <- list(beta0 = 0,
beta1=0,
theta.c = 0,
theta.ci = 0,
gamma1=0,
gamma0 = 0)
## Build/Compile model, including steps:
## (1) build model (2) compile model in C++
## (3) specify MCMC parameters to collect and create MCMC algorithm
cwdspatmodel <- nimbleModel(modelcode, constants = constants, data = data, inits = inits)
c.cwdspatmodel <- compileNimble(cwdspatmodel, showCompilerOutput = TRUE)
# year samp will be the number of years we're getting CWD samples for
yearSamp<-c(seq(2003,2022, 1))
# let's create our expected value
cwd.r<-sum(cwd.mat.pos)/sum(cwd.mat.analyzed)
# create neighborhood matrix
W.nb <- poly2nb(wiStudyShp)
W <- nb2WB(W.nb)
dZIP <- nimbleFunction(
run = function(x = integer(), lambda = double(),
zeroProb = double(), log = logical(0, default = 0)) {
returnType(double())
## First handle non-zero data
if (x != 0) {
## return the log probability if log = TRUE
if (log) return(dpois(x, lambda, log = TRUE) + log(1 - zeroProb))
## or the probability if log = FALSE
else return((1 - zeroProb) * dpois(x, lambda, log = FALSE))
}
## From here down we know x is 0
totalProbZero <- zeroProb + (1 - zeroProb) * dpois(0, lambda, log = FALSE)
if (log) return(log(totalProbZero))
return(totalProbZero)
})
registerDistributions(list(
dZIP = list(
BUGSdist = "dZIP(lambda, zeroProb)",
discrete = TRUE,
range = c(0, Inf),
types = c('value = integer()', 'lambda = double()', 'zeroProb = double()')
)))
modelcode <- nimbleCode({
## priors
beta0 ~ dnorm(0.0, sd = prec.beta0)  # vague prior on intercept
gamma0 ~ dnorm(0.0, sd=prec.gamma0)
beta1~ dnorm(0.0, sd = prec.gamma1)
gamma1~ dnorm(0.0, sd = prec.beta1)
theta.c ~ dnorm(0.0, sd=prec.theta.c)
theta.ci ~ dnorm(0.0, sd=prec.theta.ci)
# priors for precision of normal distributions
prec.beta0 ~ dgamma(0.1, 0.1)
prec.gamma0 ~ dgamma(0.1, 0.1)
prec.gamma1 ~ dgamma(0.1,0.1)
prec.beta1 ~ dgamma(0.1,0.1)
prec.theta.c ~dgamma(0.1, 0.1)
prec.theta.ci ~dgamma(0.1,0.1)
prec.c ~ dgamma(0.1, 0.1)
prec.ci ~ dgamma(0.1, 0.1)
prec.h ~ dgamma(0.1, 0.1)
prec.hi ~ dgamma(0.1, 0.1)
prec.t ~ dgamma(0.1, 0.1)
prec.t.hat~dgamma(0.1,0.1)
# CAR model for spatial random effects
# phi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.c, zero_mean=0)
# psi[1:n.twnshps] ~ dcar_normal(adj[1:L], weights[1:L], num[1:n.twnshps], prec.ci, zero_mean=0)
# likelihood
for (i in 1 : n.twnshps) {
for(j in 2: n.years){
# omega[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t)
# omegaHat[i,j] ~ dnorm(s[i,j-1]*mu.hat, prec.t.hat)
log(mu[i,j]) <- theta.c*omega[i,j]+ beta1*precip[i,j] +  beta0
logit(p[i,j]) <- theta.ci * omegaHat[i,j] + gamma1*precip[i,j] + gamma0
# lambda[i,j]  ~ dnorm(0, sd=tau.t)
# lambdaHat[i,j] ~ dnorm(0, sd=tau.t.hat)
y[i,j] ~ dZIP(mu[i,j], p[i,j])
}
#   epsilon[i] <- theta[i] + phi[i]
#   epsilon.hat[i] <- psi[i] + eta[i]
theta[i] ~ dnorm(0.0, prec.c)
eta[i] ~ dnorm(0.0, prec.ci)
}
## calculate alpha
# sd.h <- sd(phi[1:n.twnshps]) # marginal SD of heterogeneity effects
sd.c <- sd(theta[1:n.twnshps])   # marginal SD of clustering (spatial) effects
# sd.hi <- sd(psi[1:n.twnshps])
sd.ci <- sd(eta[1:n.twnshps])
alpha <- sd.h / (sd.c + sd.h)
alpha.i <- sd.hi/(sd.ci + sd.hi)
sigma2 <- 1/prec.h
tau2 <- 1/prec.c
sigma2i <- 1/prec.hi
tau2i <- 1/prec.ci
tau.t <-1/prec.t
tau.t.hat <- 1/prec.t.hat
})
## Specify data and initial values
constants <- list(n.twnshps = nrow(cwd.mat.analyzed),
mu.hat=cwd.r,
n.years=length(yearSamp),
L = length(W$adj),
adj=W$adj,
weights=W$weights,
num=W$num)
data <- list(y = cwd.mat.pos,
s = cwd.mat.analyzed)
inits <- list(beta0 = 0,
beta1=0,
theta.c = 0,
theta.ci = 0,
gamma1=0,
gamma0 = 0)
## Build/Compile model, including steps:
## (1) build model (2) compile model in C++
## (3) specify MCMC parameters to collect and create MCMC algorithm
cwdspatmodel <- nimbleModel(modelcode, constants = constants, data = data, inits = inits)
c.cwdspatmodel <- compileNimble(cwdspatmodel, showCompilerOutput = TRUE)
wsi.mat.ll
cwd.mat.pos
names(wsi.mat.ll)
str(wsi.mat.ll)
str(W)
wsi.mat.late <- read.table("./wsiMatLate")
