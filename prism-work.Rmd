---
title: "prism-work"
author: "Alex Jack"
date: "2023-08-19"
output: html_document
---

```{r setup}
# RUN this chunk to make all other chunks less annoying
knitr::opts_chunk$set(echo = FALSE)
```


```{r, echo=FALSE}
#library("rgdal")
library("raster")
library("sf")
library("leafsync")
library("dplyr")
library("ggplot2")
library("stars")
library(spatialEco)
library(spatstat.random)
library(data.table)
library(geoR)
library(RColorBrewer)
library(spdep)
library(spatialreg)
library(classInt)
#library(rgeos)
library(landscapemetrics)
library(nimble)
library(coda)
library(prism)
library(terra)
library(maps)
library(raster)
library(pscl)
library(tidyverse)
library(CARBayesST)
library(INLAspacetime)
library(lme4)
library(INLA)
library(reshape2)
library(inlatools)
```
```{r load data, echo=FALSE}
wiShp<-st_read("./data/shapefiles/Wisconsin_State_Boundary_24K/Wisconsin_State_Boundary_24K.shp")
wiTwnshpShp <- st_read("./data/shapefiles/PLSS_Townships/PLSS_Townships.shp")
wsiMast <- read.csv("./data/old/WSI-MAST-CORRECTED.csv")

# use this for setting the directory for prism
#prism_set_dl_dir("C:\\Users\\jackx\\Desktop\\prism-dat-f", create=FALSE)
# wiscland landcover raster
wiLC<-rast("./data/raster/wiscland2/wiscland2_dataset/level4/wiscland2_level4.tif")
# raw cwd data from google drive sheets
# #cwd.dat.pos<-read.table(
#   "./data/wi-dat-cwd-pos.csv",
#   sep=",", header=TRUE)
## raw cwd data from google drive sheets
# #cwd.dat.analyzed<-read.table(
#   "./data/cwd-dat-num-analyzed.csv",
#   sep=",", header=TRUE)
# TODO also need to write the study shp
#cwdMatPos<-read.table("cwd.pos")
#cwdMatAnalyzed <- read.table("cwd.analyzed")
#prismPPTStudy <- read.table("prism.ppt.study.area")
wsi.mat<-read.table("./data/wsicalculated") # this is the standard WSI used by WDNR 
#wsi.mat.late <- read.table("./wsiMatLate")

#wsDatMax<-read.table("./wsMatMax")
#wsDatMean<-read.table("./wsMatMean")
#wsMatMax <- matrix(0, nrow=nrow(wsDatMax), ncol=ncol(wsDatMax))
#wsMatMean <- matrix(0, nrow=nrow(wsDatMean), ncol=ncol(wsDatMean))

popDatTwnshp<-read.table("./data/popDat")
posDat<-read.table("./data/posDatNew") # save
sampDat<-read.table("./data/sampDatNew") # save

# for male and female
posDatFemale<-read.table("./data/posDatFemale") # save
sampDatFemale<-read.table("./data/sampDatFemale") # save
posDatMale<-read.table("./data/posDatMale") # save
sampDatMale<-read.table("./data/sampDatMale") # save


posDatFemale<-posDatFemale[,-c(22)] # save
sampDatFemale<-sampDatFemale[,-c(22)] # save
posDatMale<-posDatMale[,-c(22)]# save
sampDatMale<-sampDatMale[,-c(22)] # save

# for(i in 1:nrow(wsDatMax)){
#   for(j in 1:ncol(wsDatMax)){
#     wsMatMax[i,j] = wsDatMax[i,j]
#     wsMatMean[i,j] = wsDatMean[i,j]
#     }
# }
wiCountyShp <- st_read("./data/shapefiles/County_Boundaries_24K/County_Boundaries_24K.shp")
cwdMat2<-read.table("./data/cwd-mat-long")
nztwnshps<-read.table("./data/nonzerotwnps")
WIDatClean5<-read.table("./data/WITimeSeriesDat-3-14-24")

# this will load the long format wsi table with both scaled and unscaled wsi indices
# wsi is scaled by the entirety of the study area, which are those townships with at least one sample for each year in the study period

#write.table(wsi.mat2, "./data/wsiDatnztwnshplong")
wsi.mat.nz.long <- read.table("./data/wsiDatnztwnshplong")
read.table()
```

```{r assess temporal autocorrelation}

posDatMale <- posDatMale[,-1]
posDatFemale <- posDatFemale[,-1]
sampDatMale <- sampDatMale[,-1]
sampDatFemale <- sampDatFemale[,-1]

posDatMale <- posDatMale[,-c(ncol(posDatMale))]
posDatFemale <- posDatFemale[,-c(ncol(posDatFemale))]
sampDatMale <- sampDatMale[,-c(ncol(sampDatMale))]
sampDatFemale <- sampDatFemale[,-c(ncol(sampDatFemale))]

posMatMale <- matrix(0,nrow(posDatMale), ncol(posDatMale))
sampMatMale <- matrix(0,nrow(posDatMale), ncol(posDatMale))

posMatFemale <- matrix(0,nrow(posDatMale), ncol(posDatMale))
sampMatFemale <- matrix(0,nrow(posDatMale), ncol(posDatMale))


for(i in 1:nrow(posDat)){
  for(j in 1:ncol(posDatFemale)){
    #wsiMat[i,j] <- wsi.mat[i,j]
    posMatMale[i,j] <- posDatMale[i,j]
    sampMatMale[i,j] <- sampDatMale[i,j]
    posMatFemale[i,j] <- posDatFemale[i,j]
    sampMatFemale[i,j] <- sampDatFemale[i,j]
  }
}

totalMat <- posMatMale+ posMatFemale
totalSampMat <- sampMatMale + sampMatFemale

timeSeries <- rep(0,ncol(totalMat))
timeSeriesM <- rep(0,ncol(totalMat))
timeSeriesF <- rep(0,ncol(totalMat))
for(i in 1:ncol(totalMat)){
  timeSeries[i] <- sum(totalMat[1:nrow(totalMat),i])
  timeSeriesF[i] <- sum(posMatFemale[1:nrow(posMatFemale),i])
  timeSeriesM[i] <- sum(posMatMale[1:nrow(posMatMale),i])
}
cwdYearDat <- data.frame(cwdCases=0,
                         year=unique(WIDat.hunt.y$year))
years<-unique(WIDat.hunt.y$year)
for(i in 1:length(years)){
cwdYearDat[i,]$cwdCases<-sum(WIDat.hunt.y[which(WIDat.hunt.y$year==years[i]),]$nPos, na.rm=TRUE)
}

acfT<-acf(timeSeries, type="correlation")
pacfT<-acf(cwdYearDat$cwdCases, type="partial")
# plot the objects
plot(acfT,main="Autocorrelation of Observed (M/F) CWD Cases (2002-2020)")
plot(pacfT,main="Partial Autocorrelation of Observed CWD Cases (2008-2021)")




acfF<-acf(timeSeriesF, type="correlation")
pacfF<-acf(timeSeriesF, type="partial")
plot(acfF,main="Autocorrelation of observed CWD Cases for Females (2002-2020)")
plot(pacf,main="Partial Autocorrelation of observed CWD Cases for Females (2008-2021)")



acfM<-acf(timeSeriesM, type="correlation")
pacfM<-acf(timeSeriesM, type="partial")
plot(acfM,main="Autocorrelation of observed CWD Cases for Males (2002-2020)")
plot(acfFT,main="Partial Autocorrelation of observed CWD Cases for Males (2002-2020)")
```

```{r clean data, remove islands}
# create neighborhood matrix
wiStudyShpPoly <- as(wiTwnshpShp.nz, "Spatial")
W.nb <- poly2nb(wiStudyShpPoly)
W <- nb2WB(W.nb)
wCarCM<-as.carCM(W$adj, W$weights, W$num)
bad.indx <- c()
k <- 1
for(i in 1:nrow(cwd.mat.pos)){
    if(all(cwd.mat.pos[i,]==0)){
      bad.indx[k] <- i
      k <- k + 1
    }
}
cwd.mat.pos <- cwd.mat.pos[-c(bad.indx),]
      cwd.mat.analyzed <- cwd.mat.analyzed[-c(bad.indx),]
      wiStudyShp<- wiStudyShp[-c(bad.indx),]
      wsMatMean<- wsMatMean[-c(bad.indx),]
      wsMatMax<- wsMatMax[-c(bad.indx),]
W.nb <- poly2nb(wiStudyShp)
W <- nb2WB(W.nb)
wCarCM<-as.carCM(W$adj, W$weights, W$num)
cwd.r<-sum(cwd.mat.pos)/sum(cwd.mat.analyzed)

# let's create our expected value
E <- matrix(0, nrow=nrow(cwd.mat.analyzed), ncol=ncol(cwd.mat.analyzed))
for(i in 1:nrow(cwd.mat.analyzed)){
  for(j in 1:ncol(cwd.mat.analyzed)){
    if(cwd.mat.analyzed[i,j]*cwd.r < 1){
      E[i,j] <- cwd.mat.analyzed[i,j]*cwd.r
    }else{
      E[i,j] <- log(cwd.mat.analyzed[i,j]*cwd.r)
    }
      
    }}

```
##### ANALYSIS

```{r explore data}
wsi.mat.s <- matrix(0, nrow(wsiMat), ncol(wsiMat))
for(i in 1:nrow(wsiMat)){
  wsi.mat.s[i,] <- scale(wsiMat[i,])[,1]
}
wsi.mat.s<-wsi.mat.s[,-ncol(wsi.mat.s)]
wsi.v <- as.vector(wsi.mat.s)
pos.v.ar1 <- scale(as.vector(posMat[,-ncol(posMat)]))[,1]
pos.v <- as.vector(posMat[,-1])
samp.v <- scale(as.vector(sampMat[,-1]))[,1]
z <- zeroinfl(pos.v~wsi.v + pos.v.ar1, offset=log(samp.v + 1), dist="poisson")
zinfnbin <- zeroinfl(pos.v~+pos.v.ar1)
jj<-data.frame(re = pos.v, wsi=wsi.v, pos.var1=pos.v.ar1)
sampTrend.vv<-rep(sampTrend.v,nrow(sampMat))
for(i in 2:ncol(sampMat)){
  sampTrend[i] <- sum(sampMat[,i])
}
sampTrend<-sampTrend[-1]
sampTrend.v<-scale(sampTrend)[,1]
jj<-data.frame(re = pos.v, wsi=wsi.v, pos.var1=pos.v.ar1, sampTr=sampTrend.vv)
sampTrend.v <- rep(scale(sampTrend)[,1], nrow(sampMat))
m1poiss<-lm(re ~ wsi.v + pos.v.ar1 + sampTrend.v, data=jj, offset=log(samp.v+1))
m1nbin<-lm(re ~ wsi.v + pos.v.ar1, data=jj, offset = log(samp.v+1))

wsiMatScale <- scale(wsiMat)
posMatScale <- scale(posMat)
sampMatScale <- scale(sampMat)
# create little dataframe to examine spatial autocorrelation
cwdDat<-data.frame(obs=posMat[,2], resid = zeroinfl(posMat[,2]~posMatScale[,1]+wsiMatScale[,1]+log(sampMatScale[,1] + 1))$residuals)
cwdDat$f <- (100 * cwdDat$obs)/(cwdDat$exp)
for(i in 1:nrow(sampMat)){
  if(sampMat[i,20] == 0 || posMat[i,20]==0){
    cwdDat[i,]$prev20 <- 0
  }else{
  cwdDat[i,]$prev20 <- log(posMat[i,20])/log(sampMat[i,20] + 1)
  }
}

moran.out<-moran.test(cwdDat$resid, listw=W.listw)
moran.plot(scale(cwdDat$prev1)[,1],listw=W.listw, xlab="Scaled CWD Prevalence", ylab="Neighbors Scaled Prevalence", main="Moran Scatterplot for Scaled CWD Prevalence in 2002")
moran.plot(scale(cwdDat$prev10)[,1],listw=W.listw, xlab="standardized cwd prevalence", ylab="Neighbor's Scaled Prevalence", main="Moran Scatterplot for Scaled CWD Prevalence in 2012")
moran.plot(scale(cwdDat$prev20)[,1],listw=W.listw, xlab="Scaled CWD Prevalence", ylab="Neighbor's Scaled Prevalence", main="Moran Scatterplot for Scaled CWD Prevalence in 2022")

#now we can look to see how to account for temporal autocorrelation
temp.trend <- rep(0,ncol(posMat))
tempdf<-data.frame(prev=temp.trend,year=0)
for(j in 1:ncol(posMat)){
 tempdf[j,]$prev <- sum(posMat[,j])/sum(sampMat[,j])
 tempdf[j,]$year <- j
}

sampYears <- c(2002:2022)
twnshps <- unique(sampDatFemale$twnshp)
sampYearTwnshp <- expand.grid(sampYears, twnshps)
cwdDat <- data.frame(year = sampYearTwnshp$Var1, uid = sampYearTwnshp$Var2)



templm<-lm(prev~year,data=tempdf)
plot(templm)
templm
plot(m1poiss)
summary(m1poiss)
plot(sampTrend, type="l", ylab="Number of Deer Sampled", xlab="year", main="Number of Deer Sampled Per Year (2002-2022)")
#

plot(m1poiss)
plot(m1nbin)

summary(m1nbin)
plot(m1poiss)

# fit nb
nsims=1000
nb<-MASS::glm.nb(re ~ wsi + pos.var1+sampTr + offset(log(samp.v+1)),data=jj,link=log)
nobs<-nrow(jj)
zeros.nsim<-matrix(NA, nsims,1)
beta.hat <- MASS::mvrnorm(nsims, coef(nb), vcov(nb))
theta.hat <- rnorm(nsims, nb$theta, nb$SE.theta)
xmat <- model.matrix(nb)
for(i in 1:nsims){
  mus<-exp(xmat%*%beta.hat[i,])
  new.y<-rnbinom(nobs, mu=mus, size=theta.hat[i])
  zeros.nsim[i]<-sum(new.y==0)
}
names(sampDatFemale)[2:ncol(sampDatFemale)] <- c(2002:2022)
names(posDatMale)[2:ncol(sampDatFemale)] <- c(2002:2022)
names(posDatFemale)[2:ncol(sampDatFemale)] <- c(2002:2022)
names(sampDatMale)[2:ncol(sampDatFemale)] <- c(2002:2022)

```
```{r create habitat suitability indices}
# calculate landscape adjacency
cv.adj <- c()
adjSum <- 1
cv<-data.frame(uid=WIDatClean5$uid,cv=WIDatClean5$cv)
hsiDat <- hsiDat %>% arrange(uid)
hsiDat$nb.cv <- 0
hsiDat$nb.fd <- 0
for(i in 1:nrow(cv)){
  # cv.adj[i,] <- mean(WIDatClean5[c(W$adj),],na.rm=TRUE)
  hsiDat[i,]$nb.cv <- mean(hsiDat[c(W$adj[adjSum:((adjSum-1)+W$num[i])]),]$cv)
  hsiDat[i,]$nb.fd <- mean(hsiDat[c(W$adj[adjSum:((adjSum-1)+W$num[i])]),]$fd)
  adjSum <- adjSum + W$num[i]
}
# calculate the difference between units cv and nb cv
hsiDat <- hsiDat %>% mutate(cv.diff = cv-nb.cv,fd.diff = fd-nb.fd) %>% mutate(cv.diff.sc = scale(cv.diff)[,1], fd.diff.sc = scale(fd.diff)[,1])

```

```{r echo=FALSE, INLA}
wiTwnshpShp$uid <- paste0(wiTwnshpShp$TWP, "-", wiTwnshpShp$RNG, "-", wiTwnshpShp$DIR_ALPHA)
wiStudyShp <- wiTwnshpShp %>%  filter(uid %in% WIDatClean5$uid) %>% arrange(uid)
# check for island
# wiTwnshpPoly <- as(wiStudyShp, "Spatial")
# W.nb <- poly2nb(wiTwnshpPoly)
# W <- nb2WB(W.nb) 
# island.uid <- wiTwnshpStudy[which(W$num==0),]$uid
# wiTwnshpStudy <- wiTwnshpStudy %>% filter(!(uid %in% island.uid))
# WIDatClean5 <-WIDatClean5 %>% filter(!(uid %in% island.uid))
WIDatClean5 <- WIDatClean5 %>% arrange(year, uid)
# analysis for long
WIDatClean5$idarea <- as.numeric(as.factor(WIDatClean5$uid))
WIDatClean5$idarea2 <- WIDatClean5$idarea
WIDatClean5$idtime <- 1 + as.numeric(WIDatClean5$year) - min(as.numeric(WIDatClean5$year))
WIDatClean5$idtime2 <- WIDatClean5$idtime
#wiDatLong$idgroup <- as.factor(wiDatLong$value.)
cwdDat.wide <- reshape(WIDatClean5, timevar="year", idvar=c("uid"), direction="wide")
wiTwnshpPoly <- as(wiStudyShp, "Spatial")
map <- merge(wiTwnshpPoly, cwdDat.wide, by.x = "uid")
nb <- poly2nb(map) # create nb object
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")

# create dataframes for joint analysis
x.0 <- data.frame(uid.0 = WIDatClean5$uid,
                  year.0 = WIDatClean5$year,
                  idtime.0 = WIDatClean5$idtime,
                  idtime2.0 = WIDatClean5$idtime,
                  idtime3.0= WIDatClean5$idtime,
                  idarea.0 = WIDatClean5$idarea,
                  idarea2.0 = WIDatClean5$idarea,
                  wsi.0 = WIDatClean5$wsi,
                  pos.prev.t.minus.1.0=WIDatClean5$pos.prev.t.minus.1.z,
                  x.0 = WIDatClean5$x,
                  y.0 = WIDatClean5$y,
                  nSamp.0 = WIDatClean5$nSamp,
                  cv.diff.0 = WIDatClean5$cv.diff,
                  fd.diff.0 = WIDatClean5$fd.diff,
                  prop.M.0 = as.numeric(scale(WIDatClean5$prop.M)),
                  prop.F.0 = as.numeric(scale(WIDatClean5$prop.F))
)
x.c <- data.frame(uid.c = WIDatClean5$uid,
                  year.c = WIDatClean5$year,
                  idtime.c = WIDatClean5$idtime,
                  idtime3.c =WIDatClean5$idtime,
                  idtime2.c = WIDatClean5$idtime,
                  idarea.c = WIDatClean5$idarea,
                  idarea2.c = WIDatClean5$idarea,
                  wsi.c = WIDatClean5$wsi,
                  x.c = WIDatClean5$x,
                  y.c = WIDatClean5$y,
                  nSamp.c = WIDatClean5$nSamp,
                  cv.diff.c = WIDatClean5$cv.diff,
                  fd.diff.c = WIDatClean5$fd.diff,
                  prop.M.c = scale(as.numeric(WIDatClean5$prop.M)),
                  pos.prev.t.minus.1.c=WIDatClean5$pos.prev.t.minus.1.z,
                  prop.F.c = scale(as.numeric(WIDatClean5$prop.F))
)

stack.c <- inla.stack(
  tag="fit.c",
  data=list(all.prev=cbind(WIDatClean5$prev.c,NA)),
  A = list(1),
  effects = list(
    x.c = as.data.frame(x.c)
  )
)
stack.0 <- inla.stack(
  tag="fit.0",
  data=list(all.prev=cbind(NA,WIDatClean5$prev.z)),
  A = list(1),
  effects = list(
    x.0 = as.data.frame(x.0)
  ))

stack.t <- inla.stack(stack.c, stack.0)
```
```{r fit without correlation structure}

f.hurdle.no.corr <- all.prev ~ -1 +  idtime.c +
scale(wsi.c) + male.c + scale(y.c) + 
scale(cv.diff.c) + 
male.0 + scale(wsi.0) + scale(cv.diff.0) +
scale(y.0) + idtime.0 + scale(nSamp.0)
hurdle.out.no.corr<-inla(f.hurdle.no.corr, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

resid<-hurdle.out.no.corr$residuals$deviance.residuals
# check residual structure

count<-cbind(stack.t$data$data$all.prev.1,resid)
z<-cbind(stack.t$data$data$all.prev.2,resid)



residDat <- as.data.frame(cbind(resid, stack.t$effects$data$year.c))
names(residDat) <- c("resid","year")
plot(resid~year,data=residDat)


residDat$x = stack.t$effects$data$x.c
residDat$y = stack.t$effects$data$y.c

#####
##create plot to show spatial clustering of data
#####
coordinates(residDat) <- c(residDat$x,residDat$y)
bubble(residDat, "resid", col=c("black", "grey"),
       main="Residuals", xlab="X-coordinates", ylab="y-coordinates")

W.nb <- poly2nb(wiStudyShp)


residDat$count.prev<-stack.t$data$data$all.prev.1
residDat$z.prev<-stack.t$data$data$all.prev.2
residDat$sex <- stack.t$effects$data$group.c
moranDat.2020 <- residDat %>% filter(!is.na(count.prev) &
                                                  year == 2020) %>% arrange(uid)%>%
  filter(sex == "M") 

wiMoranShp.2020 <- wiStudyShp %>% filter(uid %in% moranDat.2020$uid) %>% 
  arrange(uid)
# remove islands
W.nb <- poly2nb(wiMoranShp.2020)
W <- nb2WB(W.nb)
moranDat.2020 <- moranDat.2020[-c(which(W$num==0)),]
wiMoranShp.2020 <- wiMoranShp.2020[-c(which(W$num==0)),]
W.nb <- poly2nb(wiMoranShp.2020)
W <- nb2WB(W.nb)
W.listw <- nb2listw(W.nb)

(moran.out<-moran.test(moranDat.2020$resid,
                       listw=W.listw, na.action = na.omit))
moran.plot(moranDat.2020$resid,listw=W.listw, xlab="Deviance Residual",
           ylab="Neighbors Neighbors Deviance Residual",
           main="Moran Scatterplot for Male CWD Prevalence in 2020")


residDat$count.prev<-stack.t$data$data$all.prev.1
residDat$z.prev<-stack.t$data$data$all.prev.2
residDat$sex <- stack.t$effects$data$group.c
moranDat.2020.f <- residDat %>% filter(!is.na(count.prev) &
                                                  year == 2020) %>% arrange(uid)%>%
  filter(sex == "F") 

wiMoranShp.2020.f <- wiStudyShp %>% filter(uid %in% moranDat.2020.f$uid) %>% 
  arrange(uid)
# remove islands
W.nb <- poly2nb(wiMoranShp.2020.f)
W <- nb2WB(W.nb)
moranDat.2020.f <- moranDat.2020.f[-c(which(W$num==0)),]
wiMoranShp.2020.f <- wiMoranShp.2020.f[-c(which(W$num==0)),]
W.nb <- poly2nb(wiMoranShp.2020.f)
W <- nb2WB(W.nb)
W.listw <- nb2listw(W.nb)
(moran.out<-moran.test(moranDat.2020.f$resid,
                       listw=W.listw, na.action = na.omit))
moran.plot(moranDat.2020.f$resid,listw=W.listw, xlab="Deviance Residual",
           ylab="Neighbors Neighbors Deviance Residual",
           main="Moran Scatterplot for Female CWD Prevalence in 2020")



# plot the pacf
residDatSum <- residDat %>% group_by(year) %>% summarise(mean.resid=mean(resid, na.rm=TRUE))
pacf(residDatSum$mean.resid, na.action=na.pass)
(pacf<-pacf(residDatSum$mean.resid, plot=FALSE, na.action=na.pass))

```


```{r model selection}
##################################################################################################################################################################### MOdels with Random Effects only###################################################################################

# intercept only model
# 44104.40
f.hurdle.intercept.only <- all.prev ~ 1
hurdle.out.intercept.only<-inla(f.hurdle.intercept.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# hurdle AR(1)
# 42473.51
f.hurdle.ar.1.only <- all.prev ~ -1 + 
f(pos.prev.t.minus.1.c, model = "ar1") + 
f(pos.prev.t.minus.1.0, model = "ar1")
hurdle.out.ar.1.only<-inla(f.hurdle.ar.1.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# iid temporal
# waic 38463.61
f.hurdle.rand.temporal <- all.prev ~ -1 + 
f(idtime.c, model = "iid") + f(idtime.0, model = "iid")
hurdle.out.rand.temporal<-inla(f.hurdle.rand.temporal, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# hurdle AR(1) + iid temporal
# 34733.45
f.hurdle.ar.1.and.iid.temporal <- all.prev ~ -1 + 
f(pos.prev.t.minus.1.c, model = "ar1") + 
f(pos.prev.t.minus.1.0, model = "ar1") +f(idtime.c, model = "iid") + f(idtime.0, model = "iid") 
hurdle.out.ar.1.and.iid.temporal<-inla(f.hurdle.ar.1.and.iid.temporal, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))


# hurdle BESAG only
# 37044.98
f.hurdle.besag.only <- all.prev ~ -1 +
f(idarea.c, model = "besag", graph = g, scale.model=TRUE) +   
f(idarea.0, model = "besag", graph = g, scale.model=TRUE)
hurdle.out.besag.only<-inla(f.hurdle.besag.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# hurdle iid only
# 37083.16
f.hurdle.spatial.iid.only <- all.prev ~ -1 + f(idarea2.c, model="iid", graph=g) +  
f(idarea2.0, model="iid", graph=g)
hurdle.out.spatial.iid.only<-inla(f.hurdle.spatial.iid.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# hurdle BESAG + iid
# 36960.83
f.hurdle.besag.and.iid <- all.prev ~ -1 +
f(idarea.c, model = "besag", graph = g, scale.model=TRUE) + f(idarea2.c, model="iid", graph=g) +   
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) + 
f(idarea2.0, model="iid", graph=g)
hurdle.out.besag.and.iid<-inla(f.hurdle.besag.and.iid, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# hurdle with random space and time components
# 32821
f.hurdle.rand.space.time <- all.prev ~ -1 + f(idarea2.c, model="iid", graph=g) + 
f(pos.prev.t.minus.1.c, model = "ar1") + 
f(idarea.c, model = "besag", graph = g) + f(idtime.c, model = "iid") + f(idtime.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1") + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g)

hurdle.out.rand.space.time<-inla(f.hurdle.rand.space.time, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))




########################################################################################################################################################################## MOdels with Fixed and Random Effects ################################################################################

# sex only (both components)
# all that matters is the spread, the passage of time and the location
# 32512.10
f.hurdle.fixed.sex.only <- all.prev ~ -1 + f(idarea2.c, model="iid", graph=g) + 
f(pos.prev.t.minus.1.c, model = "ar1") + male.c + 
f(idarea.c, model = "besag", graph = g) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1")  + male.0 + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g)
hurdle.out.fixed.sex.only<-inla(f.hurdle.fixed.sex.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# wsi only (both components)
# all that matters is the spread, the passage of time and the location
# 32822.70
f.hurdle.fixed.wsi.only <- all.prev ~ -1 + f(idarea2.c, model="iid", graph=g) + 
f(pos.prev.t.minus.1.c, model = "ar1") + scale(wsi.c) + 
f(idarea.c, model = "besag", graph = g) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1")  + scale(wsi.0) + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g)
hurdle.out.fixed.wsi.only<-inla(f.hurdle.fixed.wsi.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))


# time only (both components)
# all that matters is the spread, the passage of time increase
# 32820.78
f.hurdle.fixed.time.only <- all.prev ~ -1 + f(idarea2.c, model="iid", graph=g) + 
f(pos.prev.t.minus.1.c, model = "ar1") + idtime.c + 
f(idarea.c, model = "besag", graph = g) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1")  + idtime.0  + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g)
hurdle.out.fixed.time.only<-inla(f.hurdle.fixed.time.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# coords only
# 
f.hurdle.fixed.coords.only <- all.prev ~ -1 + f(idarea2.c, model="iid", graph=g) + 
f(pos.prev.t.minus.1.c, model = "ar1") + scale(y.c) +
f(idarea.c, model = "besag", graph = g) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1") + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g) + scale(y.0)
hurdle.out.fixed.coords.only<-inla(f.hurdle.fixed.coords.only, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# sex + wsi + time model in both components
# 32509.33
f.hurdle.fixed.sex.wsi <- all.prev ~ -1 + scale(wsi.c) + male.c +
f(idarea2.c, model="iid", graph=g) + f(pos.prev.t.minus.1.c, model = "ar1") + 
f(idarea.c, model = "besag", graph = g, scale.model=TRUE) + f(idtime2.c, model = "iid") +
male.0 + scale(wsi.0) + f(idtime2.0, model = "iid") +
f(pos.prev.t.minus.1.0, model = "ar1")  + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g)
hurdle.out.fixed.sex.wsi.time<-inla(f.hurdle.fixed.sex.wsi,
                                    family=c("zeroinflatednbinomial0",
                                             "binomial"),
                                    data=inla.stack.data(stack.t),
                                    control.compute=list(dic=TRUE,waic=TRUE),
                                    control.predictor=list(link=1,
                                                           A=inla.stack.A(stack.t)))



# sex + wsi + time model in both components
# 32509.33
f.hurdle.fixed.sex.wsi.time <- all.prev ~ -1 + scale(wsi.c) + male.c + idtime.c +
f(idarea2.c, model="iid", graph=g) + f(pos.prev.t.minus.1.c, model = "ar1") + 
f(idarea.c, model = "besag", graph = g, scale.model=TRUE) + f(idtime2.c, model = "iid") +
male.0 + scale(wsi.0) + idtime.0 + f(idtime2.0, model = "iid") +
f(pos.prev.t.minus.1.0, model = "ar1")  + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) +
f(idarea2.0, model="iid", graph=g)
hurdle.out.fixed.sex.wsi.time<-inla(f.hurdle.fixed.sex.wsi.time,
                                    family=c("zeroinflatednbinomial0",
                                             "binomial"),
                                    data=inla.stack.data(stack.t),
                                    control.compute=list(dic=TRUE,waic=TRUE),
                                    control.predictor=list(link=1,
                                                           A=inla.stack.A(stack.t)))

# sex + wsi time model in both components; fixed effect and yinla
# 32438.82
f.hurdle.fixed.sex.wsi.time.coords.nSamp0 <- all.prev ~ -1 +  idtime.c + f(idarea2.c, model="iid", graph=g) + 
f(pos.prev.t.minus.1.c, model = "ar1") + scale(wsi.c) + male.c + scale(y.c) +
f(idarea.c, model = "besag", graph = g) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1")  + male.0 + scale(wsi.0) + 
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) + 
f(idarea2.0, model="iid", graph=g) + scale(y.0) + idtime.0 + scale(nSamp.0)
hurdle.out.fixed.sex.wsi.time.coords.nSamp0<-inla(f.hurdle.fixed.sex.wsi.time.coords.nSamp0, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# sex + wsi + time fixed effect on y cv
# 32425.53
f.hurdle.fixed.sex.wsi.time.coords.nSamp0.cv <- all.prev ~ -1 +  idtime.c +
f(idarea2.c, model="iid", graph=g) + f(idtime3.c, model="ar1") +
scale(wsi.c) + prop.M.c + f(idarea.c, model = "besag", graph = g, scale.model=TRUE) +
scale(cv.diff.c) + f(idtime2.c, model = "iid") +
prop.M.0 + scale(wsi.0) + scale(cv.diff.0) +
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) + 
f(idarea2.0, model="iid", graph=g) + idtime.0 + scale(nSamp.0) + f(idtime3.0, model="ar1")
hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv<-inla(f.hurdle.fixed.sex.wsi.time.coords.nSamp0.cv, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# sex + wsi + time fixed effect on y fd
# 32437.87
f.hurdle.fixed.sex.wsi.time.coords.nSamp0.fd <- all.prev ~ -1 +  idtime.c +
f(idarea2.c, model="iid", graph=g) + f(pos.prev.t.minus.1.c, model = "ar1") +
scale(wsi.c) + male.c + scale(y.c) +f(idarea.c, model = "besag", graph = g) +
scale(fd.diff.c) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") + 
f(pos.prev.t.minus.1.0, model = "ar1")+ male.0 + scale(wsi.0) + scale(fd.diff.0) +
f(idarea.0, model = "besag", graph = g, scale.model=TRUE) + 
f(idarea2.0, model="iid", graph=g) + scale(y.0) + idtime.0 + scale(nSamp.0)
hurdle.out.fixed.sex.wsi.time.coords.nSamp0.fd<-inla(f.hurdle.fixed.sex.wsi.time.coords.nSamp0.fd, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))

# table for combined zero and cohuunt process
#./data/FinalTable-RETREAT-not-zero-split
# make INLA stacks
```
```{r}
WIDat.hunt.y <- WIDat.hunt.y %>% arrange(year, uid)
WIDat.hunt.y$prop.PMA <- if_else(WIDat.hunt.y$nMA==0,NA,WIDat.hunt.y$nPMA/WIDat.hunt.y$nPos)
# analysis for long
WIDat.hunt.y$idarea <- as.numeric(as.factor(WIDat.hunt.y$uid))
WIDat.hunt.y$idarea2 <- as.numeric(as.factor(WIDat.hunt.y$uid))
WIDat.hunt.y$idtime <- 1 + as.numeric(WIDat.hunt.y$year) - min(as.numeric(WIDat.hunt.y$year))
WIDat.hunt.y$idtime2 <- 1 + as.numeric(WIDat.hunt.y$year) - min(as.numeric(WIDat.hunt.y$year))
WIDat.hunt.y$idtime3 <- 1 + as.numeric(WIDat.hunt.y$year) - min(as.numeric(WIDat.hunt.y$year))
cwdDat.wide <- reshape(WIDat.hunt.y, timevar="year", idvar=c("uid"), direction="wide")
wiTwnshpPoly <- as(wiStudyShp, "Spatial")
map <- merge(wiTwnshpPoly, cwdDat.wide, by.x = "uid")
nb <- poly2nb(map) # create nb object
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")

# create dataframes for joint analysis
x.0 <- data.frame(uid.0 = WIDat.hunt.y$uid,
                  year.0 = WIDat.hunt.y$year,
                  idtime.0 = WIDat.hunt.y$idtime,
                  idtime2.0 = WIDat.hunt.y$idtime,
                  idtime3.0= WIDat.hunt.y$idtime,
                  idarea.0 = WIDat.hunt.y$idarea,
                  idarea2.0 = WIDat.hunt.y$idarea,
                  wsi.0 = WIDat.hunt.y$wsi,
                  x.0 = WIDat.hunt.y$x,
                  y.0 = WIDat.hunt.y$y,
                  nSamp.0 = WIDat.hunt.y$nSamp,
                  cv.diff.0 = WIDat.hunt.y$cv.diff,
                  fd.diff.0 = WIDat.hunt.y$nMY,
                  fd.diff.0 = WIDat.hunt.y$fd.diff,
                  fd.diff.0 = WIDat.hunt.y$fd.diff,
                  fd.diff.0 = WIDat.hunt.y$fd.diff, 
                  prop.MA.0 = WIDat.hunt.y$prop.MA,
                  prop.MY.0 = WIDat.hunt.y$prop.MY,
                  prop.FA.0 = WIDat.hunt.y$prop.FA,
                  prop.FY.0 = WIDat.hunt.y$prop.FY,
                  nMA.0 = WIDat.hunt.y$nMA,
                  nMY.0 = WIDat.hunt.y$nMY,
                  nFA.0 = WIDat.hunt.y$nFA,
                  nFY.0 = WIDat.hunt.y$nFY,
                  nPMA.0 = WIDat.hunt.y$nPMA,
                  nPMY.0 = WIDat.hunt.y$nPMY,
                  nPFA.0 = WIDat.hunt.y$nPFA,
                  nPFY.0 = WIDat.hunt.y$nPFY,
                  nPos.t.minus.1.0 = WIDat.hunt.y$nPos.t.minus.1,
                  snopack.max.0 = WIDat.hunt.y$snopackMax,
                  numDays0sno.0 = WIDat.hunt.y$numDays0sno,
                  numDayssno.0 = WIDat.hunt.y$numDays,
                  wsi.early.0 = WIDat.hunt.y$wsi.early,
                  wsi.ttl.0 = WIDat.hunt.y$wsi.ttl,
                  wsi.late.0 = WIDat.hunt.y$wsi.late,
                  pop.0 = WIDat.hunt.y$pop
)

x.c <- data.frame(uid.c = WIDat.hunt.y$uid,
                  year.c = WIDat.hunt.y$year,
                  idtime.c = WIDat.hunt.y$idtime,
                  idtime3.c =WIDat.hunt.y$idtime,
                  idtime2.c = WIDat.hunt.y$idtime,
                  idarea.c = WIDat.hunt.y$idarea,
                  idarea2.c = WIDat.hunt.y$idarea,
                  wsi.c = WIDat.hunt.y$wsi,
                  x.c = WIDat.hunt.y$x,
                  y.c = WIDat.hunt.y$y,
                  nSamp.c = WIDat.hunt.y$nSamp,
                  cv.diff.c = WIDat.hunt.y$cv.diff,
                  fd.diff.c = WIDat.hunt.y$fd.diff,                  
                  prop.MA.c = WIDat.hunt.y$prop.MA,
                  prop.MY.c = WIDat.hunt.y$prop.MY,
                  prop.FA.c = WIDat.hunt.y$prop.FA,
                  prop.FY.c = WIDat.hunt.y$prop.FY,
                  nMA.c = WIDat.hunt.y$nMA,
                  nMY.c = WIDat.hunt.y$nMY,
                  nFA.c = WIDat.hunt.y$nFA,
                  nFY.c = WIDat.hunt.y$nFY,
                  nPMA.c = WIDat.hunt.y$nPMA,
                  nPMY.c = WIDat.hunt.y$nPMY,
                  nPFA.c = WIDat.hunt.y$nPFA,
                  nPFY.c = WIDat.hunt.y$nPFY,
                  nPos.t.minus.1.c = WIDat.hunt.y$nPos.t.minus.1,
                  snopack.max.c = WIDat.hunt.y$snopackMax,
                  numDays0sno.c = WIDat.hunt.y$numDays0sno,
                  numDayssno.c = WIDat.hunt.y$numDays,
                  wsi.early.c = WIDat.hunt.y$wsi.early,
                  wsi.ttl.c = WIDat.hunt.y$wsi.ttl,
                  wsi.late.c = WIDat.hunt.y$wsi.late,
                  pop.c = WIDat.hunt.y$pop
)

stack.c <- inla.stack(
  tag="fit.c",
  data=list(all.prev=cbind(WIDat.hunt.y$nPos.c,NA)),
  A = list(1),
  effects = list(
    x.c = as.data.frame(x.c)
  )
)
stack.0 <- inla.stack(
  tag="fit.0",
  data=list(all.prev=cbind(NA,WIDat.hunt.y$nPos.z)),
  A = list(1),
  effects = list(
    x.0 = as.data.frame(x.0)
  ))

stack.t <- inla.stack(stack.c, stack.0)
f.hurdle.wsi.total <- all.prev ~ -1 +
 offset(log(nSamp.c)) + prop.MA.c + f(idtime2.0, model="iid") + f(idtime2.c, model="iid") + 
  scale(wsi.ttl.0) + f(idarea.c, model = "bym", graph = g, scale.model=TRUE) +
  f(idtime3.c, model="ar1") + f(idtime3.0, model="ar1") + 
  scale(wsi.ttl.c) + f(idarea.0, model = "bym", graph = g, scale.model=TRUE) + scale(pop.0) + scale(pop.c) + offset(log(nSamp.0)) + prop.MA.0


f.hurdle.wsi.late <- all.prev ~ -1 +
 offset(nSamp.c) + prop.MA.c + f(idtime2.0, model="iid") + f(idtime2.c, model="iid") + 
  scale(wsi.late.c) + f(idarea.c, model = "bym", graph = g, scale.model=TRUE) +
  f(idtime3.c, model="ar1") + f(idtime3.0, model="ar1") + 
  scale(wsi.late.0) + f(idarea.0, model = "bym", graph = g, scale.model=TRUE) +
  prop.MA.0 + scale(pop.0) + scale(pop.c) + offset(nSamp.0)

f.hurdle.wsi.early <- all.prev ~ -1 +
 offset(nSamp.c) + prop.MA.c + f(idtime2.0, model="iid") + f(idtime2.c, model="iid") + 
  scale(wsi.early.c) + f(idarea.c, model = "bym", graph = g, scale.model=TRUE) +
  scale(cv.diff.c) + f(idtime3.c, model="ar1") + f(idtime3.0, model="ar1") + 
  scale(wsi.early.0) + scale(cv.diff.0) + f(idarea.0, model = "bym", graph = g, scale.model=TRUE) + prop.MA.0 + scale(pop.0) + scale(pop.0) + scale(pop.c) + offset(nSamp.0)

f.hurdle.0.sno <- all.prev ~ -1 +
 offset(nSamp.c) + prop.MA.c + f(idtime2.0, model="iid") + f(idtime2.c, model="iid") + 
  scale(numDays0sno.c) + f(idarea.c, model = "bym", graph = g, scale.model=TRUE) +
  f(idtime3.c, model="ar1") + f(idtime3.0, model="ar1") + 
  scale(numDays0sno.0) +
  f(idarea.0, model = "bym", graph = g, scale.model=TRUE) +
  prop.MA.0 + scale(pop.0) + scale(pop.c) + offset(nSamp.0)

f.hurdle.max.snopack <- all.prev ~ -1 + scale(pop.c) + 
 offset(nSamp.c) + prop.MA.c + f(idtime2.0, model="iid") + f(idtime2.c, model="iid") + 
  scale(snopack.max.c) + f(idarea.c, model = "bym", graph = g, scale.model=TRUE) +
  f(idtime3.c, model="ar1") + f(idtime3.0, model="ar1") + 
  scale(snopack.max.0) + f(idarea.0, model = "bym", graph = g, scale.model=TRUE)+ 
  prop.MA.0 + scale(pop.0) + offset(nSamp.0)

f.hurdle.num.sno.days <- all.prev ~ -1 +
  offset(nSamp.c) + prop.MA.c + f(idtime2.0, model="iid") +
  f(idtime2.c, model="iid") + scale(numDayssno.c) +
  f(idarea.c, model = "bym", graph = g, scale.model=TRUE) +
  f(idtime3.c, model="ar1") + f(idtime3.0, model="ar1") + 
  scale(numDayssno.0) + f(idarea.0, model = "bym", graph = g, scale.model=TRUE) +
  prop.MA.0 + scale(pop.0) + scale(pop.c) + offset(nSamp.0)

hurdle.out.wsi.total<-inla(f.hurdle.wsi.total,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE, config=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))


f.negbin <- nPos ~ -1 + offset(log(nSamp)) + scale(prop.MA) + f(idtime2, model="iid") + scale(wsi.ttl) + f(idarea, model = "bym", graph = g, scale.model=TRUE) + f(idtime, model="ar1") + scale(pop) + idtime3
# fit WSI total with no joint

f.negbin.0.sno <- nPos ~ -1 + offset(log(nSamp)) + prop.MA + f(idtime2, model="iid") + scale(numDays0sno) + f(idarea, model = "bym", graph = g, scale.model=TRUE) + f(idtime, model="ar1") + scale(pop)


f.negbin.snopack.max <- nPos ~ -1 + offset(log(nSamp)) + scale(prop.MA) + f(idtime2, model="iid") + scale(snopackMax) + f(idarea, model = "bym", graph = g, scale.model=TRUE) + f(idtime, model="ar1") + scale(pop)

out.negbin<-inla(f.negbin, family=c("nbinomial"), data=WIDat.hunt.y, control.compute=list(dic=TRUE,waic=TRUE,config=TRUE),
     control.predictor=list(link=1), control.inla=list(strategy='simplified.laplace'))

out.negbin.0.sno<-inla(f.negbin.0.sno, family=c("nbinomial"), data=WIDat.hunt.y, control.compute=list(dic=TRUE,waic=TRUE,config=TRUE),
     control.predictor=list(link=1), control.inla=list(strategy='simplified.laplace'))


out.negbin.snopack.max<-inla(f.negbin.snopack.max, family=c("nbinomial"), data=WIDat.hunt.y, control.compute=list(dic=TRUE,waic=TRUE,config=TRUE),
     control.predictor=list(link=1), control.inla=list(strategy='simplified.laplace'))

shurdle.out.wsi.early<-inla(f.hurdle.wsi.early,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))


hurdle.out.wsi.late<-inla(f.hurdle.wsi.late,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))


hurdle.out.num.snodays<-inla(f.hurdle.num.sno.days,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))

hurdle.out.max.snopack<-inla(f.hurdle.max.snopack,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))

hurdle.out.0.sno<-inla(f.hurdle.0.sno,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))
# get raw resids
# for count part
logit.out<-data.frame(obs=WIDat.hunt.y$nPos.z, exp=abs(hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y$residuals$deviance.residuals[(nrow(WIDat.hunt.y)+1):(2*nrow(WIDat.hunt.y))]), exp=(WIDat.hunt.y$prop.MA +
WIDat.hunt.y$idtime + WIDat.hunt.y$cv.diff +  WIDat.hunt.y$nPos.t.minus.1) + WIDat.hunt.y$wsi)

ggplot(logit.out, aes(exp.1,obs))+theme_bw()+
    geom_point(position = position_jitter(w = 2, h = 0.05), size=3) +
    geom_smooth(colour="red") + xlab("Expectation") +
    ylab("Detection = 1")


```

```{r using same model make predictions}
x.pred <- data.frame(uid = WIDat.hunt.y$uid,
                     year = WIDat.hunt.y$year,
                     idtime = WIDat.hunt.y$idtime,
                     idtime2 = WIDat.hunt.y$idtime,
                     idtime3= WIDat.hunt.y$idtime,
                     idarea = WIDat.hunt.y$idarea,
                     idarea2 = WIDat.hunt.y$idarea,
                     wsi = WIDat.hunt.y$wsi,
                     x = WIDat.hunt.y$x,
                     y = WIDat.hunt.y$y,
                     nSamp = WIDat.hunt.y$nSamp,
                     cv.diff = WIDat.hunt.y$cv.diff,
                     fd.diff = WIDat.hunt.y$nMY,
                     fd.diff = WIDat.hunt.y$fd.diff,
                     fd.diff = WIDat.hunt.y$fd.diff,
                     fd.diff = WIDat.hunt.y$fd.diff, 
                     prop.MA = WIDat.hunt.y$prop.MA,
                     prop.MY = WIDat.hunt.y$prop.MY,
                     prop.FA = WIDat.hunt.y$prop.FA,
                     prop.FY = WIDat.hunt.y$prop.FY,
                     nMA = WIDat.hunt.y$nMA,
                     nMY = WIDat.hunt.y$nMY,
                     nFA = WIDat.hunt.y$nFA,
                     nFY = WIDat.hunt.y$nFY,
                     nPMA = WIDat.hunt.y$nPMA,
                     nPMY = WIDat.hunt.y$nPMY,
                     nPFA = WIDat.hunt.y$nPFA,
                     nPFY = WIDat.hunt.y$nPFY,
                     nPos.t.minus.1 = WIDat.hunt.y$nPos.t.minus.1,
                     snopack.max = WIDat.hunt.y$snopackMax,
                     numDays0sno = WIDat.hunt.y$numDays0sno,
                     numDayssno = WIDat.hunt.y$numDays,
                     wsi.early = WIDat.hunt.y$wsi.early,
                     wsi.ttl = if_else(WIDat.hunt.y$wsi.ttl==0,0, WIDat.hunt.y$wsi.ttl- 1),
                     wsi.late = WIDat.hunt.y$wsi.late,
                     pop = WIDat.hunt.y$pop
)

x.dat <- data.frame(uid = WIDat.hunt.y$uid,
                    year = WIDat.hunt.y$year,
                    idtime = WIDat.hunt.y$idtime,
                    idtime3 =WIDat.hunt.y$idtime,
                    idtime2 = WIDat.hunt.y$idtime,
                    idarea = WIDat.hunt.y$idarea,
                    idarea2 = WIDat.hunt.y$idarea,
                    wsi = WIDat.hunt.y$wsi,
                    x = WIDat.hunt.y$x,
                    y = WIDat.hunt.y$y,
                    nSamp = WIDat.hunt.y$nSamp,
                    cv.diff = WIDat.hunt.y$cv.diff,
                    fd.diff = WIDat.hunt.y$fd.diff,                  
                    prop.MA = WIDat.hunt.y$prop.MA,
                    prop.MY = WIDat.hunt.y$prop.MY,
                    prop.FA = WIDat.hunt.y$prop.FA,
                    prop.FY = WIDat.hunt.y$prop.FY,
                    nMA = WIDat.hunt.y$nMA,
                    nMY = WIDat.hunt.y$nMY,
                    nFA = WIDat.hunt.y$nFA,
                    nFY = WIDat.hunt.y$nFY,
                    nPMA = WIDat.hunt.y$nPMA,
                    nPMY = WIDat.hunt.y$nPMY,
                    nPFA = WIDat.hunt.y$nPFA,
                    nPFY = WIDat.hunt.y$nPFY,
                    nPos.t.minus.1 = WIDat.hunt.y$nPos.t.minus.1,
                    snopack.max = WIDat.hunt.y$snopackMax,
                    numDays0sno = WIDat.hunt.y$numDays0sno,
                    numDayssno = WIDat.hunt.y$numDays,
                    wsi.early = WIDat.hunt.y$wsi.early,
                    wsi.ttl = WIDat.hunt.y$wsi.ttl,
                    wsi.late = WIDat.hunt.y$wsi.late,
                    pop = WIDat.hunt.y$pop
)


# make a prediction stack
stk.pred <- inla.stack(tag="fit.pred",
  data=list(nPos=NA),
  A = list(1),
  effects = list(
    x.pred = as.data.frame(x.pred)
  )) 
  # make a prediction stack
stk.dat <- inla.stack(tag="fit.dat",
  data=list(nPos=WIDat.hunt.y$nPos),
  A = list(1),
  effects = list(
    x.dat = as.data.frame(x.dat)
  ))

stk.full <- inla.stack(stk.dat, stk.pred)
f.negbin <- nPos ~ -1 + offset(log(nSamp)) + prop.MA + f(idtime2, model="iid") + scale(wsi.ttl) + f(idarea, model = "bym", graph = g, scale.model=TRUE) + f(idtime, model="ar1") + scale(pop)

# fit WSI total with no joint
out.negbin.dat<-inla(f.negbin, family=c("nbinomial"), data=WIDat.hunt.yf, control.compute=list(dic=TRUE,waic=TRUE,config=TRUE),
     control.predictor=list(link=1), control.inla=list(strategy='simplified.laplace'))


hurdle.out.wsi.late<-inla(f.hurdle.wsi.late,
        family=c("zeroinflatednbinomial0", "binomial"),                                                       data=inla.stack.data(stack.t),                                                   control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1,A=inla.stack.A(stack.t)),
control.inla=list(strategy='simplified.laplace'))

```



```{r sex models}
```

# split into age and sex class models


```{r transform nPos.t.minus.1 }

```



```{r male adult}
WIDatSexSplitM <- WIDatSexSplitM %>% arrange(year, uid)
# analysis for long
WIDatSexSplitM$nPM.0 <- if_else(WIDatSexSplitM$nPos > 0, 1, WIDatSexSplitM$nPos)
WIDatSexSplitM$nPM.c <- if_else(WIDatSexSplitM$nPos == 0, NA, WIDatSexSplitM$nPos)
WIDatSexSplitM <- WIDatSexSplitM %>% filter(year < 2022)
WIDatSexSplitM$idarea <- as.numeric(as.factor(WIDatSexSplitM$uid))
WIDatSexSplitM$idarea2 <- as.numeric(as.factor(WIDatSexSplitM$uid))
WIDatSexSplitM$idtime <- 1 + as.numeric(WIDatSexSplitM$year) - min(as.numeric(WIDatSexSplitM$year))
WIDatSexSplitM$idtime2 <- 1 + as.numeric(WIDatSexSplitM$year) - min(as.numeric(WIDatSexSplitM$year))
cwdDat.wide <- reshape(WIDatSexSplitM, timevar="year", idvar=c("uid"), direction="wide")
wiTwnshpPoly <- as(wiStudyShp, "Spatial")
map <- merge(wiTwnshpPoly, cwdDat.wide, by.x = "uid")
nb <- poly2nb(map) # create nb object
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
# need to transform each of our responses as with above
x.m.0 <- data.frame(uid.0 = WIDatSexSplitM$uid,
                  year.0 = WIDatSexSplitM$year,
                  idtime.0 = WIDatSexSplitM$idtime,
                  idtime2.0 = WIDatSexSplitM$idtime,
                  idtime3.0= WIDatSexSplitM$idtime,
                  idarea.0 = WIDatSexSplitM$idarea,
                  idarea2.0 = WIDatSexSplitM$idarea,
                  wsi.0 = WIDatSexSplitM$wsi,
                  x.0 = WIDatSexSplitM$x,
                  y.0 = WIDatSexSplitM$y,
                  nSamp.0 = WIDatSexSplitM$nSamp,
                  cv.diff.0 = WIDatSexSplitM$cv.diff,
                  cv.diff.0 = WIDatSexSplitM$cv.diff,
                  fd.diff.0 = WIDatSexSplitM$fd.diff
                  )

x.m.c <- data.frame(uid.c = WIDatSexSplitM$uid,
                  year.c = WIDatSexSplitM$year,
                  idtime.c = WIDatSexSplitM$idtime,
                  idtime3.c =WIDatSexSplitM$idtime,
                  idtime2.c = WIDatSexSplitM$idtime,
                  idarea.c = WIDatSexSplitM$idarea,
                  idarea2.c = WIDatSexSplitM$idarea,
                  wsi.c = WIDatSexSplitM$wsi,
                  x.c = WIDatSexSplitM$x,
                  y.c = WIDatSexSplitM$y,
                  nSamp.c = WIDatSexSplitM$nSamp,
                  cv.diff.c = WIDatSexSplitM$cv.diff,
                  fd.diff.c = WIDatSexSplitM$fd.diff                  
)


stack.m.c <- inla.stack(
  tag="fit.c",
  data=list(all.prev=cbind(WIDatSexSplitM$nPM.c,NA)),
  A = list(1),
  effects = list(
    x.c = as.data.frame(x.m.c)
  )
)
stack.m.0 <- inla.stack(
  tag="fit.0",
  data=list(all.prev=cbind(NA,WIDatSexSplitM$nPM.0)),
  A = list(1),
  effects = list(
    x.0 = as.data.frame(x.m.0)
  ))
stack.m.t <- inla.stack(stack.m.c, stack.m.0)

f.hurdle.fixed.sex.wsi.time.coords.nSamp0.cv.y.ma <- all.prev ~ -1 +  idtime.c +
  f(idarea2.c, model="iid", graph=g) + offset(nSamp.c) +
  scale(wsi.c) + f(idarea.c, model = "besag", graph = g, scale.model=TRUE) +
  scale(cv.diff.c) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") +
  scale(wsi.0) + scale(cv.diff.0) + f(idarea.0, model = "besag", graph = g,   scale.model=TRUE) + f(idarea2.0, model="iid", graph=g) + idtime.0 
hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y.ma<-inla(f.hurdle.fixed.sex.wsi.time.coords.nSamp0.cv.y.ma, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.m.t), control.compute=list(dic=TRUE,waic=TRUE,residuals=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.m.t)))

```

```{r female adult}

# need to transform each of our responses as with above
WIDat.hunt.y$nPFA.0 <- if_else(WIDat.hunt.y$nPFA > 0, 1, WIDat.hunt.y$nPFA) 
WIDat.hunt.y$nPFA.c <- if_else(WIDat.hunt.y$nPFA == 0, NA, WIDat.hunt.y$nPFA)

stack.fa.c <- inla.stack(
  tag="fit.c",
  data=list(all.prev=cbind(WIDat.hunt.y$nPFA.c,NA)),
  A = list(1),
  effects = list(
    x.c = as.data.frame(x.c)
  )
)
stack.fa.0 <- inla.stack(
  tag="fit.0",
  data=list(all.prev=cbind(NA,WIDat.hunt.y$nPFA.0)),
  A = list(1),
  effects = list(
    x.0 = as.data.frame(x.0)
  ))
stack.t.fa <- inla.stack(stack.fa.c, stack.fa.0)

f.hurdle.fixed.sex.wsi.time.coords.nSamp0.cv.y.fa <- all.prev ~ -1 +  idtime.c +
  f(idarea2.c, model="iid", graph=g) + offset(nFA.c) +
  scale(wsi.c) + f(idarea.c, model = "besag", graph = g, scale.model=TRUE) +
  scale(cv.diff.c) + f(idtime2.c, model = "iid") + f(idtime2.0, model = "iid") +
  scale(wsi.0) + scale(cv.diff.0) + f(idarea.0, model = "besag", graph = g,   scale.model=TRUE) + f(idarea2.0, model="iid", graph=g) + idtime.0 
hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y.fa<-inla(f.hurdle.fixed.sex.wsi.time.coords.nSamp0.cv.y.fa, family=c("zeroinflatednbinomial0", "binomial"), data=inla.stack.data(stack.t.fa), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t.fa)))
```
```{r}

```

```{r sensitivity analysis}
UN.prior = "expression:
  log_dens = 0 - log(2) - theta / 2;
  return(log_dens);
"

prior.list = list(
  uniform = list(prec = list(prior = UN.prior)),
  pc.prec = list(prec = list(prior = "pc.prec", param = c(5, 0.01)))

)

prior.list.0 = list(
  default = list(prec = list(prior = "loggamma", param = c(1, 0.00005))),
  pc.prec = list(prec = list(prior = "pc.prec", param = c(5, 0.01))),
  uniform = list(prec = list(prior = "uniform", param = c(0,100)))  
)

# this call works for lapply, the  binomial doesn't have any hyperpars
# 
#     inla(all.prev ~ -1 +  idtime.c +
# f(idarea2.c, model="iid", graph=g, hyper=tau.prior) + f(pos.prev.t.minus.1.c, model = "ar1", hyper=tau.prior) +
# scale(wsi.c) + male.c + scale(y.c) + f(idarea.c, model = "besag", graph = g, hyper=tau.prior) +
# scale(cv.diff.c) + f(idtime2.c, model = "iid", tau.prior) + f(idtime2.0, model = "iid") + 
# f(pos.prev.t.minus.1.0, model = "ar1")+ male.0 + scale(wsi.0) + scale(cv.diff.0) +
# f(idarea.0, model = "besag", graph = g, scale.model=TRUE) + 
# f(idarea2.0, model="iid", graph=g) + scale(y.0) + idtime.0 + scale(nSamp.0), family=c("zeroinflatednbinomial0", "binomial"),
#                data=inla.stack.data(stack.t),
#                control.compute=list(dic=TRUE,waic=TRUE),
#                control.predictor=list(link=1, A=inla.stack.A(stack.t)),
#                control.family = list(list(hyper=list(theta = list(prior = "pc.prec", param = c(5, 0.01)))),
#                                      list()))


# want to try priors suggested by Fieberg for the binomial distribution

sens.out<-lapply(prior.list, function(tau.prior) {
    inla(all.prev ~ -1 +  idtime.c +
f(idarea2.c, model="iid", graph=g, hyper=tau.prior) + f(pos.prev.t.minus.1.c, model = "ar1", hyper=tau.prior) +
scale(wsi.c) + male.c + scale(y.c) + f(idarea.c, model = "besag", graph = g, hyper=tau.prior) +
scale(cv.diff.c) + f(idtime2.c, model = "iid", hyper=tau.prior) + f(idtime2.0, model = "iid", hyper=tau.prior) + 
f(pos.prev.t.minus.1.0, model = "ar1")+ male.0 + scale(wsi.0) + scale(cv.diff.0) +
f(idarea.0, model = "besag", graph = g, scale.model=TRUE, hyper=tau.prior) + 
f(idarea2.0, model="iid", graph=g, hyper=tau.prior) + scale(y.0) + idtime.0 + scale(nSamp.0), family=c("zeroinflatednbinomial0", "binomial"),
               data=inla.stack.data(stack.t),
               control.compute=list(dic=TRUE,waic=TRUE),
               control.predictor=list(link=1, A=inla.stack.A(stack.t)))
    })




```

```{r}
# plot results of posterior
hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y$names.fixed
names<-c("year","proportion male","WSI","neighborhood cover difference",
"WSI","neighborhood cover difference","idtime", "proportion male")
component<- c("nbinom","nbinom","nbinom","nbinom","binom","binom","binom","binom")
postDat <- data.frame(name = names, component=component)
postDat$est <- hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y$summary.fixed$mean
postDat$LCL <- hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y$summary.fixed$'0.025quant'
postDat$UCL <- hurdle.out.fixed.sex.wsi.time.coords.nSamp0.cv.y$summary.fixed$'0.975quant'

ggplot(postDat, aes(component, est)) +
  geom_errorbar(aes(ymin=LCL, ymax=UCL), width=0.2) +
  facet_wrap(~name, scales="free") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r INLA model validation}
# hurdle model
hurdle.out <- mix.out


nobs.fitted.3<-hurdle.out.pc$summary.fitted.values[,"mean"]

# calculate pearson residuals for model
p.resid.3 <- (WIDatClean5$pos.prev.nz - nobs.fitted.3)

# want to know how it works for the count process
# grab the indices that have zero components
hurdle.res.dat <- data.frame(pearson=p.resid,
                             fitted=hurdle.out.pc$summary.fitted.values[,'mean'],
                             obs=WIDatClean5$pos.prev)
hurdle.res.dat2 <- data.frame(pearson=p.resid.3,
                             fitted=hurdle.out.pc.3$summary.fitted.values[,'mean'],
                             obs=WIDatClean5$pos.prev)
ggplot(hurdle.res.dat, aes(x=obs, y=fitted)) + 
  geom_point()

groups <- c("FA", "FY", "FJ",
            "MA", "MY", "MJ")

hurdle.out.dat <- data.frame(groups=groups, mean=0, LCI=0, UCI=0)
for(i in 1:length(groups)){
  hurdle.out.dat[i,]$mean = hurdle.out.pc.4$summary.fixed[paste0("group", groups[i], ":wsi.sc"),]$mean
  hurdle.out.dat[i,]$UCI = hurdle.out.pc.4$summary.fixed[paste0("group", groups[i], ":wsi.sc"),]$"0.975quant"
}


plot(x=log(WIDatClean5$pos.prev.nz),y=log(nobs.fitted.3)) 
plot(nobs.fitted.3,residuals(hurdle.out.pc,type="pearson"))
ggplot(hurdle.out.dat)
ggplot(data = hurdle.out.dat, aes(x=groups)) +
  geom_point(aes(y=mean)) + 
  geom_errorbar(aes(ymin = LCI, ymax = UCI)) +
    theme_bw()
```
```{r validation fit with training and testing data}
WIDatClean5$pos.prev.0 <- if_else(WIDatClean5$pos.prev==0,0,1)
WIDatClean5$pos.prev.nz <- if_else(WIDatClean5$pos.prev>0,WIDatClean5$pos.prev,NA)

# for k-fold validation we need to split the data into K=10 folds

set.seed(55407)
split = c(train=.8, validate=.2)


g = sample(cut(
  seq(nrow(WIDatClean5)), 
  nrow(WIDatClean5)*cumsum(c(0,split)),
  labels = names(split)
))

index_val <- which(g=="validate")
index_train <- which(g=="train")

WIDatClean5$pos.prev.0.pred <- WIDatClean5$pos.prev.0
WIDatClean5$pos.prev.0.pred[c(index_val)] <- NA

WIDatClean5$pos.prev.nz.pred <- WIDatClean5$pos.prev.nz
WIDatClean5$pos.prev.nz.pred[c(index_val)] <- NA



cwdDat.wide <- reshape(WIDatClean5, timevar="year", idvar=c("uid"), direction="wide")
wiTwnshpPoly <- as(wiStudyShp, "Spatial")
map <- merge(wiTwnshpPoly, cwdDat.wide, by.x = "uid", by.y = "uid")
nb <- poly2nb(map) # create nb object
nb2INLA("map.adj", nb)
g <- inla.read.graph(filename = "map.adj")
# table for combined zero and count process
f.hurdle.joint <- all.prev ~  idtime.nz + scale(wsi.nz) + male.nz + MY.prev.t.samp.sc.nz + wsi.nz:FY.prev.sc.nz + f(idtime2.nz, model="iid") + f(idarea2.nz, model="iid", graph=g, hyper=prior.list$pc.prec) + f(pos.prev.t.minus.1.sc.nz, model = "ar1") + cv.nz + fd.nz + f(idarea.nz, model = "besag", graph = g, hyper=prior.list$pc.prec)  + f(idtime2.0, model="iid") + idtime0 + wsi.0 + MA.prev.t.samp.sc.0 + MY.prev.t.samp.sc.0 + f(pos.prev.t.minus.1.sc.0, model = "ar1") + f(idarea.0, model = "besag", graph = g, hyper=prior.list$pc.prec, scale.model=TRUE) + x.0 + y.0 + cv.0 + fd.0 + f(idarea2.0, model="iid", graph=g, hyper=prior.list$pc.prec) + nSamp.0

# total stack
# stack.t <- inla.stack(stack.nz, sstack.0)
# 
# 
# pred.0 <- stack.t$data

# specify formula
# f.hurdle.joint <- all.prev ~  idtime.nz + wsi.nz + MA.prev.t.samp.sc.nz + MY.prev.t.samp.sc.nz + wsi.nz:FY.prev.sc.nz + f(idtime2.nz, model="iid") + f(idarea2.nz, model="iid", graph=g, hyper=prior.list$pc.prec) + f(pos.prev.t.minus.1.sc.nz, model = "ar1") + cv.nz + fd.nz + f(idarea.nz, model = "besag", graph = g, hyper=prior.list$pc.prec)  + f(idtime2.0, model="iid") + idtime0 + wsi.0 + MA.prev.t.samp.sc.0 + MY.prev.t.samp.sc.0 + f(pos.prev.t.minus.1.sc.0, model = "ar1") + f(idarea.0, model = "besag", graph = g, hyper=prior.list$pc.prec, scale.model=TRUE) + x.0 + y.0 + cv.0 + fd.0 + f(idarea2.0, model="iid", graph=g, hyper=prior.list$pc.prec) + nSamp.0
# 
# 
# hurdle.out.pc<-inla(f.hurdle.joint, family=c("nbinomial", "binomial"), data=inla.stack.data(stack.t), control.compute=list(dic=TRUE,waic=TRUE), control.predictor=list(link=1, A=inla.stack.A(stack.t)))
form.hurdle.nz.pred <- pos.prev.nz.pred ~ idtime + f(pos.prev.t.minus.1.sc, model = "ar1") + f(idarea, model = "besag", graph = g, hyper=prior.list$pc.prec) + x.sc + y.sc + fd.diff.sc + cv.diff.sc + wsi.sc

form.hurdle.0.pred <- pos.prev.0.pred ~ idtime + f(pos.prev.t.minus.1.0, model = "ar1") + f(idarea, model = "besag", graph = g, hyper=prior.list$pc.prec) + x.sc + y.sc + fd.diff.sc + cv.diff.sc + wsi.sc + scale(nSamp)[,1]

out.hurdle.nz.pred<-inla(form.hurdle.nz.pred, family=c("nbinomial"), data=WIDatClean5, control.compute=list(dic=TRUE,waic=TRUE),
     control.predictor=list(link=1),
     control.fixed = list(mean=0,
                          prec=1))
out.hurdle.0.pred<-inla(form.hurdle.0.pred, family=c("binomial"), data=WIDatClean5, control.compute=list(dic=TRUE,waic=TRUE),
     control.predictor=list(link=1),
     control.fixed = list(mean=0,
                          prec=1))

RMSE <- function(set,outcome,data,fit){
  res = data[set,outcome]-fit[set]
  RMSE_val <- sqrt(mean(res^2,na.rm=T)) 
  return(RMSE_val)  
}

pseudo_r2 <- function(set,outcome,data,fit){
  res =  data[set,outcome]-fit[set]
  RRes=sum((res)^2,na.rm = T)
  RRtot=sum((data[set,outcome]-mean(fit[set],na.rm=T))^2,na.rm = T)
  pseudo_r2_val=1-RRes/RRtot
  return(pseudo_r2_val)  
}
M_fit=out.hurdle.nz.pred$summary.fitted.values[,"mean"]
RMSE_val=RMSE(index_val,"pos.prev.nz",WIDatClean5,M_fit)
RMSE_train=RMSE(index_train,"pos.prev.nz",WIDatClean5,M_fit)

r2_val=pseudo_r2(index_val,"pos.prev.nz",WIDatClean5,M_fit)
r2_train=pseudo_r2(index_train,"pos.prev.nz",WIDatClean5,M_fit)

WIDatClean5$set <- "" 
WIDatClean5[index_val,]$set <-"validation"
WIDatClean5[index_train,]$set <- "train"

ggplot(WIDatClean5, aes(x=pos.prev.nz, y=out.hurdle.nz.pred$summary.fitted.values[,'mean'], group=set, color=set, alpha=set)) + 
  geom_point() +
  geom_abline(intercept=0, slope=1)


ggplot(WIDatClean5, aes(x=log(out.hurdle.0.pred$summary.fitted.values[,'mean']), y=pos.prev.0, group=set, color=set, alpha=set)) + 
  geom_point() +
  geom_line(aes(x=log(out.hurdle.0.pred$summary.fitted.values[,'mean']),pos.prev.0))  

```
